import docker
import networkx as nx
import os
import matplotlib.pyplot as plt
from networkx.drawing.nx_agraph import graphviz_layout

def run_mulval():
    client = docker.from_env()
    client.containers.list()
    cwd = os.getcwd()
    print "cwd", cwd
    print "mulval_related_dir", cwd + '/mulval_inouts'
    # note: going to start container running everytime (and later on will detelete it...)
    container = client.containers.run("risksense/mulval", detach=True,
                                      volumes={cwd + '/mulval_inouts': {'bind': '/mnt/vol2', 'mode': 'rw'}})
    print "cwd", cwd

    commands = [ ['/root/mulval/utils/graph_gen.sh', '/mnt/vol2/test_mulval_input.P'],
                 ['mv', '/root/mulval/utils/xsb_log.txt', '/mnt/vol2/xsb_log.txt'],
                 ['mv', '/root/mulval/utils/AttackGraph.txt', '/mnt/vol2/AttackGraph.txt']]
    for command in commands:
        out = container.exec_run(command, workdir='/root/mulval/utils/')
        print out #out.output, out

    print client.containers.list()

    print container.stop()
    print container.remove()
    #print client.containers.prune(filters={'id': container.id})

## NOTE: there can be NO - chars in mulval input... it causes problems with the trace parser!!
def prepare_mulval_input(ms_s, mapping, sensitive_ms):
    # this is going to need to take the k8s input files and then convert to the input format for mulval
    ### TODO: okay, I think that this is the next step...
    ### Stuff to include:
    ###    internet <-> anything it wants, anything it wants
    ###    pods  -> send anywhere, anything
    ###    vips -> get set of three rules, heavily dictating what they accept and what they don't
    ###    + each pod can get the same vulnerability (so 2 lines + shared)
    ###    + each vip gets its own vulnerability (so 3 lines...)

    ## so we can break this down into two steps...
    ## (1) acquire all the config-related information
    ## (2) convert it into the mulval-compatible form...

    ## okay, well let's obviously start w/ (1)... can we leverage existing parsing
    ## capabilities to get it done?? looks like kinda, but not completely, b/c it puts everything
    ## into the 'mapping' dict, instead of keeping everything seperate...
    ## just us the ms (list of microservices) to filter the mappings and that'll be fine...
    ## so next step is wiring it in... comment out other parts afterr

    # step 1a: get list of services + pods... wait no, that's wrong... we only care about ms_s...
    # the mapping to the concrete pods happens in postprocessing... so we can create the model
    # declarivitevly via the following logic...
    svcs = []
    for ms in ms_s:
        ms = ms.replace('-','_')
        svcs.append( (ms + '_pod', ms+ '_vip', ms) )

    # step 2. let's generate the corresponding test_mulval_input.P
    # step 2.a. the internet (can talk to/from anything)
    lines = ['%autogenerated','hacl(internet, _, _, _).']
    lines.append('attackGoal(execCode(internet, _)).')
    lines.append('vulExists(internet, \'attacker_can_access_anything\', is_computer).')
    lines.append('networkServiceInfo(internet, is_computer, _, _, _).')

    # i think these only needed to be included once...
    lines.append('vulProperty(\'attacker_can_access_anything\', remoteExploit, privEscalation).')
    ### vulProperty('attacker_can_access_anything', remoteExploit, privEscalation).
    lines.append('vulProperty(\'is_a_vip\', remoteExploit, privEscalation).')  ## TODO
    # vulProperty('is_a_vip', remoteExploit, privEscalation).

    # step 2.b. the hacl's ; do simulteanously for VIPs and Pods
    # recall that pods can do whatever they want, vips are more limited (obvi)
    sensitive_node = None
    for svc in svcs:
        if sensitive_ms.replace('-','_') in svc[0]:
            sensitive_node = svc[0]
            print "sensitive_node", sensitive_node
            lines.append('attackerLocated(' + svc[0] + ').')

        # pod is easy
        lines.append('')
        print 'svc', svc
        #if 'dns_pod' not in svc[0]:
        #    lines.append( 'hacl(' + svc[0] + ', _, _, _).' )
        #else:
        #if 'dns_pod' in svc[0]:
        lines.append( 'hacl(' + svc[0] + ', internet, _, _).' )
        # VIP is harder
        port, proto = None,None
        for svc_two in svcs:
            print mapping
            for ip,individ_mapping in mapping.iteritems():
                try:
                    print svc[2], individ_mapping
                    if svc[2] in individ_mapping[0].replace('-','_') and 'VIP' in individ_mapping[0]:
                        port,proto = individ_mapping[2][0], individ_mapping[3][0]
                except:
                    pass

            print port, proto
            if svc_two != svc:
                print "svc_two", svc_two[0], svc[1],proto,port
                if 'dns_pod' not in svc_two[0] and 'dns_vip' not in svc_two[0]:
                    ## TODO: remove lower if-statement when we want to re-enable the full range of exfil possibilities
                    if 'dns_vip' not in svc[1] or svc_two[0] == sensitive_node:
                        lines.append(  'hacl(' + svc_two[0] +',' + svc[1] + ', ' + proto +', ' + port[0] + ').'  )
                if 'dns_pod' not in svc[0] and 'dns_vip' not in svc_two[1]:
                    ## TODO: remove lower if-statement when we want to re-enable the full range of exfil possibilities
                    if 'dns_vip' not in svc[0] or svc_two[1] == sensitive_node:
                        lines.append(  'hacl(' + svc_two[1] +',' + svc[0] + ', ' + proto +', ' + port[0] + ').'  )
                #          e.g. hacl(webServer_pod, fileServer_vip, TCP, 67).
                if 'dns_pod' not in svc[0]:
                    if 'dns_pod' not in svc_two[1]:
                        ## TODO: remove lower if-statement when we want to re-enable the full range of exfil possibilities
                        if 'dns_vip' not in svc_two[1]:
                            lines.append(  'hacl(' + svc[0] +',' + svc_two[1] + ', ' + proto +', ' + port[0] + ').'  )
                    if 'dns_pod' not in svc_two[0]:
                        ## TODO: remove lower if-statement when we want to re-enable the full range of exfil possibilities
                        if 'dns_vip' not in svc_two[1]:
                            lines.append(  'hacl(' + svc[0] +',' + svc_two[0] + ', ' + proto +', ' + port[0] + ').'  )

        print svc, svc[2]
        lines.append( 'hacl(' + svc[0] +',' + svc[1] + ', ' +proto + ', ' + port[0] + ').')
        #e.g. hacl(fileServer_pod, fileServer_vip, TCP, 67).
        lines.append( 'hacl(' + svc[1] +','+ svc[0] + ', ' + '_' + ', ' + '_' + ').' )
        #e.g. hacl(fileServer_vip, fileServer_pod, TCP, 80).

        # step 2.c. then do the vulneabiltiy stuff (should be very 'boilerplate')
        ### for pod, it is very boilerplate
        lines.append('vulExists(' + svc[0] + ', \'attacker_can_access_anything\', is_computer).')
        ### vulExists(fileServer_pod, 'attacker_can_access_anything', is_computer).
        lines.append('networkServiceInfo(' + svc[0] + ', is_computer,  _, _ , _).')
        ### networkServiceInfo(fileServer_pod, is_computer,  TCP, 80 , _).

        ### for vip, it is slightly less boilerplate...
        lines.append('vulExists(' + svc[1] + ', \'is_a_vip\', is_vip).')
        #vulExists(webServer_vip, 'is_a_vip', is_vip).
        lines.append('networkServiceInfo(' + svc[1] + ', is_vip, ' + proto + ', ' + port[0] + ', _).')
        #networkServiceInfo(webServer_vip, is_vip, TCP, 87, _).


        ## NOTE: I need port information!!! This will require reworking the mapping functions!!!!
        #### TODO: Immediate next steps
        ####   (a) modify mapping to get ports + feed them into mulval component
        ####   (b) incorporate logic into this
        ####   (c) finish input preparer by modifying new_old_test_mulval_input w/ application-info
        ####   (d) finish the output processor (might be a bit of work...)
        #### would be nice if I could get through c today
        #### OKAY, did not quite get through c today... gotta finish c tomorrow and then do the output
        #### preparer... essentially, just reverse the logic (b/c we wanna go out, not in) and make some graphs...
        #### I'm not sure if the desired graph is an array of d3's, but it might be... anyway, probably best to
        #### just keep it simple for now, and then can focus in on the specifics later... well actually, I kinda would
        #### like the array, but let's make it a flag for it, and only trigger it on when the __main__ thing happens...
        #### also, obviously, we're just putting a single node for each pod (maybe later we can put more if we want...)
        #### yah, def. do hte grid...

    with open('./mulval_inouts/test_mulval_input.P', 'w') as f:
        for line in lines:
            f.write(line)
            f.write('\n')

    print 'MAPS MAPS MAPS'
    for maps,vals in mapping.iteritems():
        print maps,vals

    return sensitive_node # do I want to return anything??

def post_process_mulval_result(sensitive_node):
    # well, not in accordance with the architecture document, if we're putting orchestrator logic into the
    # mulval component, then we'd need to include the 'chaining' together of various steps

    graph = open('./mulval_inouts/AttackGraph.txt', 'r')
    lines = graph.readlines()
    hacls = []
    for line in lines:
        if 'hacl' in line:
            hacls.append(line.rstrip().lstrip())
    propogation_graph_edges = []
    for hacl in hacls:
        only_hacl =  hacl.split('-', 1)[1]
        only_relevant = only_hacl.split('(')[1].split(')')[0]
        #print only_hacl, only_relevant.split(',')#onfly_hacl.split('('), only_hacl.split(',')
        propogation_graph_edges.append(only_relevant.split(','))

    # okay, for now we should use the simplest visualization process possible... networkx it is then...
    G = nx.DiGraph() # this'll be the propogation graph...
    # okay, so it looks like it is going to be some kinda loop....
    # looks like G.add_edge(NODE1, NODE2, weight=WEIGHT) is the way to do this...
    # so all we gotta do is a construct a set of tuples from the hacls... piece of cake...
    for edge in propogation_graph_edges:
        G.add_edge(edge[0], edge[1], proto = edge[2], port = edge[3])
        #print edge

    for edge in G.edges():
        print "edge", edge

    #nx.draw(G)
    #plt.draw()

    pos = graphviz_layout(G)
    nx.draw_networkx(G, pos, with_labels=True, arrows=True)

    # okay, so let's generate all the paths using this...
    paths=[]
    for path in nx.all_simple_paths(G, source=sensitive_node, target='internet'):
        print "a_path:", path
        paths.append(path)
    #print "paths", nx.all_simple_paths(G, source=sensitive_node, target='internet')
    # ^^ TODO:src,trgt (src is sensitive pod, dest is internet)

    # this doesn't actually seem helpful...
    #for cycle in nx.simple_cycles(G):
    #    print "a_cycle", cycle

    initiator_info = determine_initator(paths)
    print "initiator_info",initiator_info

    ## TODO: might wanna include the line below again...
    ## ZZBBFF
    #plt.show()

    print "has the graph been drawn???? yes, yes they have"
    return paths, initiator_info

def generate_synthetic_attack_templates(mapping, ms_s,sensitive_ms):
    sensitive_node = prepare_mulval_input(ms_s, mapping, sensitive_ms)
    run_mulval()
    paths, initiator_info = post_process_mulval_result(sensitive_node)
    return paths, initiator_info

def determine_initator(paths):
    initiator_info = {} # a dict mapping (first_node,second_node) -> (initiator, 'initiator'),
                        # where 'initiator' exists to reading this code later on more clear
    for path in paths:
        for i in range(0, len(path)-1):
            first,second=path[i],path[i+1]
            if (first,second) not in initiator_info:
                # this if exists b/c initiator info is a property of the names, so won't very if shows up
                # multiple times...

                # okay, so there are three rules that we need to observe here...
                # rule 1: if both are pods / internet, then either can be the initiator
                if 'vip' not in first and 'vip' not in second: #pod,pod
                    initiator_info[(first,second)] = ('?', 'initiator')
                elif 'vip' not in first and 'vip' in second: #pod,vip
                    first_basename = first.replace('_pod', '') # recall, could also be internet
                    second_basename = second.replace('_vip', '')
                    if first_basename == second_basename:
                        initiator_info[(first, second)] = (second, 'initiator')
                    else:
                        initiator_info[(first, second)] = (first, 'initiator')
                elif 'vip' in first and 'vip' not in second: #vip,pod
                    first_basename = first.replace('_vip', '')
                    second_basename = second.replace('_pod', '')
                    if first_basename == second_basename:
                        initiator_info[(first, second)] = (first, 'initiator')
                    else:
                        initiator_info[(first, second)] = (second, 'initiator')
                else:
                    exit(12) # ERROR, should not be possible, need to check the mulval component thoroughly...

    return initiator_info


if __name__ == "__main__":
    generate_synthetic_attack_templates([], [])